-- This file is a part of OPEN FORMATS I/O project, (C) Alexander Blade, MIXAZZZ
-- dev-c.com, openiv.com

-- Description: skel
-- Last changed: Jan 2015

global ofio_iv_opened_blocks

global g_skel_bone_index_using_id = #()
global g_skel_bone_id_using_index = #()

struct ofio_iv_bone (
	name,
	Flags,
	Index,
	Id,
	Mirror,
	LocalOffset,
	RotationEuler,
	RotationQuaternion,
	Scale,
	WorldOffset,
	Orient,
	Sorient,
	TransMin,
	TransMax,
	RotMin,
	RotMax,
	Children = #(),
	
	boneObject,
	
	fn scanline fInput = (
		if eof(fInput) then throw "unexpected eof"	
		local l = readLine(fInput)
		local s = filterString l "\x20\x09"
		if s.count == 1 then
			if s[1] == "{" then ofio_iv_opened_blocks += 1 else
				if s[1] == "}" then ofio_iv_opened_blocks -= 1
		l = undefined	
		return s
	),
	
	fn cleanup = (
		local child
		for child in Children do child.cleanup()
		Children = #()
		try (if boneObject != undefined then delete boneObject) catch()
	),
	
	fn dumpPrepare obj numbones = (
		numbones += 1
		local id = getUserProp obj "id"
		if id == undefined then throw ("skeleton bone " + obj.name + " id is undefined")
		g_skel_bone_index_using_id[id + 1] = numbones - 1
		
		setUserProp obj "_ignore_this_autogenerated_index" (numbones - 1)
		
		if obj.Children.Count > 0 then
		(
			local i
			for i = 1 to obj.Children.Count do
			(
				if ofutils.lowercase(getUserProp obj.Children[i] "type") != "bone"
					then continue
				local child = ofio_iv_bone()
				numbones = child.dumpPrepare obj.Children[i] numbones
				child = undefined
			)
		)
		
		return numbones
	),
	
	fn dump obj numbones root:false = (
		numbones += 1
		boneObject = obj
		local pi_to_deg = 57.2958		
		-- name
		name = obj.name
		-- local offset, rotation and scale
		Scale = obj.scale - obj.parent.scale
		if root then
		(
			RotationQuaternion = obj.rotation
			LocalOffset = obj.pos
		) else
		(
			in coordsys obj.parent 
			(
				RotationQuaternion = obj.rotation
				LocalOffset = obj.pos
			)
		)
		RotationEuler = RotationQuaternion as eulerangles -- WARN: RotationEuler is not the same as original one 
		RotationEuler.x /= pi_to_deg * -1
		RotationEuler.y /= pi_to_deg * -1
		RotationEuler.z /= pi_to_deg * -1
		-- world offset	
		WorldOffset = obj.pos
		
		Id = getUserProp boneObject "id"
		if Id == undefined then throw ("skeleton bone " + name + " id is undefined")		
		Index = g_skel_bone_index_using_id[Id + 1]
		if Index == undefined then throw ("skeleton bone " + name + " index error")
		
		Mirror = Index
		local mirrorId = getUserProp boneObject "mirrorId"
		if mirrorId != undefined then 
		(
			Mirror = g_skel_bone_index_using_id[mirrorId + 1]
			if Mirror == undefined then throw ("skeleton bone " + name + " mirror index error, no such bone found")		
		)
		
		Flags = execute(getUserProp boneObject "flags") 
		if Flags == undefined then throw ("skeleton bone " + name + " flags are undefined")
		TransMin = execute(getUserProp boneObject "transmin") 
		if TransMin == undefined then TransMin = Point3 0.0 0.0 0.0
		TransMax = execute(getUserProp boneObject "transmax") 
		if TransMax == undefined then TransMax = Point3 0.0 0.0 0.0
		RotMin = execute(getUserProp boneObject "rotmin") 
		if RotMin == undefined then RotMin = Point3 -3.14 -3.14 -3.14
		RotMax = execute(getUserProp boneObject "rotmax")
		if RotMax == undefined then RotMax = Point3 3.14 3.14 3.14

		Orient = RotationEuler
		Sorient = Point3 0.0 0.0 0.0
		
		Children = #()
		if obj.Children.Count > 0 then
		(
			local i
			for i = 1 to obj.Children.Count do
			(
				if ofutils.lowercase(getUserProp obj.Children[i] "type") != "bone"
					then continue
				local child = ofio_iv_bone()
				numbones = child.dump obj.Children[i] numbones
				append Children child
			)
		)
		
		return numbones
	),
	
	fn buildPrepare = (
		g_skel_bone_id_using_index[Index + 1] = Id
		if Children.count > 0 then
		(
			local i
			for i = 1 to Children.count do
				Children[i].buildPrepare()
		)		
	),
	
	fn build par:undefined = (
		local pi_to_deg = 57.2958
		boneObject = dummy boxsize:[0, 0, 0] wirecolor:yellow showlinks:true
		boneObject.name = name
		
		boneObject.scale = par.scale + Scale
		local roteuler = eulerangles (RotationEuler[1] * pi_to_deg) (RotationEuler[2] * pi_to_deg) (RotationEuler[3] * pi_to_deg)
		in coordsys par (
			boneObject.rotation = RotationQuaternion
			boneObject.pos = LocalOffset
		)
		setUserProp boneObject "type" "bone"
		setUserProp boneObject "flags" Flags
		setUserProp boneObject "id" Id
		setUserProp boneObject "mirrorId" g_skel_bone_id_using_index[Mirror+1]
		setUserProp boneObject "transmin" TransMin 
		setUserProp boneObject "transmax" TransMax
		setUserProp boneObject "rotmin" RotMin
		setUserProp boneObject "rotmax" RotMax
		
		setUserPropBuffer boneObject ((getUserPropBuffer boneObject) + "\r\n------ params below are being used for optimized anim export -----\r\n")
		setUserProp boneObject "orig_position" LocalOffset
		setUserProp boneObject "orig_rotation" RotationQuaternion
		
		if Children.count > 0 then
		(
			local i
			for i = 1 to Children.count do
				Children[i].build par:boneObject
		)
		boneObject.parent = par
	),
	
	fn write fOutput padding = (
		format "%bone %\n%{\n" padding name padding to:fOutput
		format ("%\x09" + "Flags ") padding to:fOutput
		local flag
		for flag in Flags do 
			format "% " flag to:fOutput
		format "\n" to:fOutput
		format "%\x09Index %\n" padding Index to:fOutput
		format "%\x09Id %\n" padding Id to:fOutput
		format "%\x09Mirror %\n" padding Mirror to:fOutput
		format "%\x09LocalOffset % % %\n" padding LocalOffset[1] LocalOffset[2] LocalOffset[3] to:fOutput
		format "%\x09RotationEuler % % %\n" padding RotationEuler.x RotationEuler.y RotationEuler.z to:fOutput
		format "%\x09RotationQuaternion % % % %\n" padding RotationQuaternion.x RotationQuaternion.y RotationQuaternion.z RotationQuaternion.w to:fOutput
		format "%\x09Scale % % %\n" padding Scale[1] Scale[2] Scale[3] to:fOutput
		format "%\x09WorldOffset % % %\n" padding WorldOffset[1] WorldOffset[2] WorldOffset[3] to:fOutput
		format "%\x09Orient % % %\n" padding Orient.x Orient.y Orient.z to:fOutput
		format "%\x09Sorient % % %\n" padding Sorient[1] Sorient[2] Sorient[3] to:fOutput
		format "%\x09TransMin % % %\n" padding TransMin[1] TransMin[2] TransMin[3] to:fOutput
		format "%\x09TransMax % % %\n" padding TransMax[1] TransMax[2] TransMax[3] to:fOutput
		format "%\x09RotMin % % %\n" padding RotMin[1] RotMin[2] RotMin[3] to:fOutput
		format "%\x09RotMax % % %\n" padding RotMax[1] RotMax[2] RotMax[3] to:fOutput		
		if Children.Count > 0 then
		(
			format ("%\x09" + "Children %\n%\x09{\n") padding Children.Count padding to:fOutput
			local child
			for child in Children do
				child.write fOutput (padding + "\x09\x09")
			format "%\x09}\n" padding to:fOutput
		)
		format "%}\n" padding to:fOutput
	),
	
	fn read fInput = (
		local i, elements
		elements = scanline fInput
		if ofutils.lowercase(elements[1]) != "bone" then throw "bone expected"
		name = elements[2]
		elements = scanline fInput
		if elements[1] != "{" then throw "bone data start expected"
		elements = scanline fInput
		while elements[1] != "}" do
		(
			case ofutils.lowercase(elements[1]) of
			(
				"flags": 
				(
					flags = #()
					for i = 2 to elements.count do
						append flags elements[i]
					
				)
				"index": Index = elements[2] as Integer
				"id": Id = elements[2] as Integer
				"mirror": Mirror = elements[2] as Integer
				"localoffset": LocalOffset = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"rotationeuler": RotationEuler = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"rotationquaternion": RotationQuaternion = Quat (elements[2] as Float) (elements[3] as Float) (elements[4] as Float) (elements[5] as Float)
				"scale": Scale = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"worldoffset": WorldOffset = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"orient": Orient = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"sorient": Sorient = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"transmin": TransMin = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"transmax": TransMax = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"rotmin": RotMin = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"rotmax": RotMax = Point3 (elements[2] as Float) (elements[3] as Float) (elements[4] as Float)
				"children":
				(
					local count = elements[2] as Integer
					elements = scanline fInput
					if elements[1] != "{" then throw "bone children start expected"					
					Children = #()
					for i = 1 to count do
					(
						local child = ofio_iv_bone()
						child.read fInput
						append Children child
					)
					elements = scanline fInput
					if elements[1] != "}" then throw "bone children end expected"					
				)
				
				default: throw ("unknown bone data " + elements[1])
			)
			elements = scanline fInput
		)
	)
)

struct ofio_iv_skeleton (
	descriptor,
	flags,	
	rootBone,
	numbones,
	
	HaveBoneWorldOrient,
	
	fn read fInputName = (
		local fInput = openFile fInputName
		local version = filterString (readLine fInput) "\x20\x09"	
		if (version[2] as Integer != 107) or (version[3] as Integer != 11) then
		(
			close fInput
			throw "not supported skel, version 107 11 is supported only"		
		)
		local numBones = filterString (readLine fInput) "\x20\x09"
		if ofutils.lowercase(numBones[1]) != "numbones" then throw "NumBones expected"
		flags = filterString (readLine fInput) "\x20\x09"
		if ofutils.lowercase(flags[1]) != "flags" then throw "Flags expected"
		deleteItem flags 1
		ofio_iv_opened_blocks = 0
		rootBone = ofio_iv_bone()
		rootBone.read fInput
		close fInput
		if ofio_iv_opened_blocks != 0 then throw "file parsing error"
		-- flags
		HaveBoneWorldOrient = false
		local flag
		for flag in flags do
			if ofutils.lowercase(flag) == "haveboneworldorient" then
				HaveBoneWorldOrient = true			
	),
	
	fn write fOutputName = (		
		local fOutput = createFile fOutputName 
		format "Version 107 11\nNumBones %\nFlags " numbones to:fOutput
		local flag
		for flag in flags do
			format "% " flag to:fOutput
		format "\n" to:fOutput
		rootBone.write fOutput ""
		close fOutput
	),
	
	fn getBoneObjectWorldOrient _orient _bone = (
		if (getUserProp _bone "type") == "bone" then
		(
			local __orient -- = execute(getUserProp _bone "__orient")
			if _bone.parent != undefined 
				then __orient = (in coordsys parent (_bone.rotation as eulerAngles))
				else __orient = _bone.rotation as eulerAngles
			__orient = Point3 __orient.x __orient.y __orient.z
			
			_orient -= __orient
			if _bone.parent != undefined then
				_orient = getBoneObjectWorldOrient _orient _bone.parent
		)
		return _orient
	),		
	
	fn boneObjUsingGameId root id = (
		if root.Id == id then
			return root.boneObject
		local child
		for child in root.Children do
		(
			if child.Id != id then
			(
				local result = boneObjUsingGameId child id
				if result != undefined then 
					return result
			) else
				return child.boneObject
		)
		return undefined
	),
	
	fn boneObjUsingName root name = (
		name = ofutils.lowercase(name)
		if ofutils.lowercase(root.name) == name then
			return root.boneObject
		local child
		for child in root.Children do
		(
			if ofutils.lowercase(child.name) != name then
			(
				local result = boneObjUsingName child name
				if result != undefined then 
					return result
			) else
				return child.boneObject
		)
		return undefined
	),	
	
	fn boneObjExists root name = (
		name = ofutils.lowercase(name)
		if ofutils.lowercase(root.name) == name then
			return true
		local child
		for child in root.Children do
		(
			if ofutils.lowercase(child.name) != name then
			(
				local result = boneObjExists child name
				if result then 
					return true
			) else
				return true
		)
		return false
	),		
	
	linked_bones = #(#(1218, 14497), #(1225, 14753)),
	
	fn build par = (
		g_skel_bone_id_using_index = #()
		rootBone.buildPrepare()
		
		descriptor = par
		setUserProp descriptor "skeleton_flags" flags
		rootBone.build par:descriptor
		local bones_pair
		for bones_pair in linked_bones do
		(
			local bone_1 = boneObjUsingGameId rootBone bones_pair[1]
			local bone_2 = boneObjUsingGameId rootBone bones_pair[2]
			if bone_1 != undefined and bone_2 != undefined then
			(
				paramWire.connect bone_1.controller[#rotation] bone_2.controller[#rotation] "rotation"
				paramWire.connect bone_1.controller[#position] bone_2.controller[#position] "position"
			)
		)
	),
	
	fn dump obj = (
		g_skel_bone_index_using_id = #()
		flags = execute(getUserProp obj.parent "skeleton_flags")
		if flags == undefined then 
			throw ("no skeleton flags found in " + obj.parent.name)
		rootBone = ofio_iv_bone()
		rootBone.dumpPrepare obj 0
		numbones = rootBone.dump obj 0 root:true
		-- flags
		HaveBoneWorldOrient = false
		local flag
		for flag in flags do
			if ofutils.lowercase(flag) == "haveboneworldorient" then
				HaveBoneWorldOrient = true	 
	),
	
	fn cleanup = (
		if rootBone != undefined then rootBone.cleanup()
		g_skel_bone_index_using_id = #()
		g_skel_bone_id_using_index = #()
	)
)
